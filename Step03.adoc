= Step 03 : Our first Endpoint
:source-highlighter: coderay

== KeyTerms

JsonObject

== Authentication (Login) Endpoint
The first endpoint we will implement is the Authentication endpoint, documented here:
https://github.com/gothinkster/realworld/blob/master/api/README.md

POST /api/users/login

Input:
[code,json]
....
{
  "user":{
    "email": "jake@jake.jake",
    "password": "jakejake"
  }
}
....

Expected Return:
[code,json]
....
{
  "user": {
    "email": "jake@jake.jake",
    "token": "jwt.token.here",
    "username": "jake",
    "bio": "I work at statefarm",
    "image": null
  }
}
....
== Approach

Our first step will be to create a test that attempts to authenticate using the example user, "jake@jake.jake"
We will then build the code to pass the test
* create a REST endpoint that accepts JSON in the expected format
* stub out the authentication and simply check hard coded values
* return the expected JSON User representation

== Test First!

Create a new class, AuthenticationEndpointTest, in the io.vertx.conduit package.  Annotate the class with:

[source,java]
....
import io.vertx.junit5.VertxExtension;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.extension.ExtendWith;

@DisplayName("Authentication Endpoint Tests")
@ExtendWith(VertxExtension.class)
public class AuthenticationEndpointTest {
....

=== Implement the Test Method

[source,java]
....
    vertx.deployVerticle(new MainVerticle(), testContext.succeeding(id -> {              <1>             
      WebClient webClient = WebClient.create(vertx);                                     <2>
      webClient.post(8080, "localhost", "/api/users/login")                              <3>
        .sendJsonObject(new JsonObject()                                                 <4>
          .put("user", new JsonObject()
            .put("email", "jake@jake.jake")
            .put("password", "jakejake")
          ), response -> testContext.verify(() -> {                                      <5>
          JsonObject user = response.result().bodyAsJsonObject().getJsonObject("user");  <6>
          assertEquals(200, response.result().statusCode());                             <7>
          assertEquals("jake@jake.jake", user.getString("email"));                       <8>
          assertEquals("jakejake", user.getString("password"));
          assertEquals("jwt.token.here", user.getString("token"));
          assertEquals("jake", user.getString("username"));
          assertEquals("I work at statefarm", user.getString("bio"));
          assertEquals("", user.getString("image"));
          testContext.completeNow();                                                     <9>
        }));
    }));
....

==== JsonObject

[source,java]
....
    JsonObject userLogin = new JsonObject()
      .put("user", new JsonObject()
          .put("email", "jake@jake.jake")
          .put("password", "jakejake")
      );

    JsonObject expectedReturn = new JsonObject()
      .put("user", new JsonObject()
        .put("email", "jake@jake.jake")
        .put("password", "jakejake")
        .put("token", "jwt.token.here")
        .put("username", "jake")
        .put("bio", "I work at statefarm")
        .put("image", ""));
....

==== Test Method
[source,java]
....
    vertx.deployVerticle(new MainVerticle(), testContext.succeeding(id -> {
      deploymentCheckpoint.flag();

      webClient.post(8080, "localhost", "/")
        .as(BodyCodec.string())
        .sendJsonObject(userLogin, resp -> {
          authenticationCheckpoint.flag();
          assertEquals(200, resp.result().statusCode());
          assertEquals(expectedReturn, resp.result().bodyAsJsonObject());
        });
    }));
....

=== Run the Test

[source,shell]
....
mvn clean test
...
[ERROR] Failures:
[ERROR]   AuthenticationEndpointTest.testSuccessfulAuthentication org.opentest4j.AssertionFailedError: expected: <{"user":{"email":"jake@jake.jake","password":"jakejake","token":"jwt.token.here","username":"jake","bio":"I work at statefarm","image":""}}> but was: <null>
[INFO]
[ERROR] Tests run: 2, Failures: 1, Errors: 0, Skipped: 0
[INFO]
[INFO] ------------------------------------------------------------------------
[INFO] BUILD FAILURE
[INFO] ------------------------------------------------------------------------
....

== Add the Route and Handler

[source,java]
....
    router.route("/api/users/login").handler(this::loginHandler);
....

== Create our Users domain model

[source,java]
....
package io.vertx.thinkster.conduit.domain;

public class User {

  private String email;

  private String token;

  private String username;

  private String bio;

  private String image;

  public User(String email, String token, String username, String bio, String image) {
    this.email = email;
    this.token = token;
    this.username = username;
    this.bio = bio;
    this.image = image;
  }

  @Override
  public String toString() {
    return "User{" +
      "email='" + email + '\'' +
      ", token='" + token + '\'' +
      ", username='" + username + '\'' +
      ", bio='" + bio + '\'' +
      ", image='" + image + '\'' +
      '}';
  }

  public User(String email) {
    this.email = email;
  }

  public String getEmail() {
    return email;
  }

  public void setEmail(String email) {
    this.email = email;
  }

  public String getToken() {
    return token;
  }

  public void setToken(String token) {
    this.token = token;
  }

  public String getUsername() {
    return username;
  }

  public void setUsername(String username) {
    this.username = username;
  }

  public String getBio() {
    return bio;
  }

  public void setBio(String bio) {
    this.bio = bio;
  }

  public String getImage() {
    return image;
  }

  public void setImage(String image) {
    this.image = image;
  }
}

....

== /api/users/login

Steps

* Create the Users object of our domain model
* Add a new route
* Attach a handler to the route
* Implement the handler
* Validate the required fields
* Extract the posted data
* Lookup the user (we will stub this out for now)
* Return the expected result


Add a new route: 

[code,java]
....
    router.route("/api/users/login").handler(this::loginHandler);
....

Implement loginHandler

[code,java]
....
    User user = new User();
    user.setUsername("vertx-user");
    user.setBio("Mock bio");
    user.setEmail("user@vertx.io");
    user.setToken("token");

    HttpServerResponse response = routingContext.response();
    response
      .putHeader("content-type", "text/html")
      .end(Json.encodePrettily(user));
....

./redeploy.sh

== Postman and Newman
update the variables with "localhost:8080/api"
pass the first Postman test Auth/login

== Handle the actual request values

Create a domain model to handle errors:

[code,java]
....
package io.vertx.thinkster.conduit.domain;

public class ConduitError {

  private Error error;

  public ConduitError() {

    this.error = new Error("Something went wrong");

  }

  public ConduitError(String body) {

    this.error = new Error(body);
  }

  public Error getError() {
    return error;
  }

  public void setError(Error error) {
    this.error = error;
  }

  private class Error {

    private String body;

    public Error(String body) {
      this.body = body;
    }

    public String getBody() {
      return body;
    }

    public void setBody(String body) {
      this.body = body;
    }

  }

}
....

